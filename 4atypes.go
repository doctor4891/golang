////////////////////////////////////////////////////////////////////////////
//////////////////////		ОСНОВНЫЕ ТИПЫ      ////////////////////////////////
//////////////////////////////////////////////////////////////////////////
package main

import (
	"fmt"
	"reflect"
)

var a4 bool = false

var b4 string = "string"

/* побитовый размах диапазона 8, 16, 32 бита то есть 2*8, 2*16 и тд.
   Это нужно для того чтобы экономно выделять память */
var symplyint = 1

var c4 int8 = 127 //от -128 до +128

var d4 int16 = -32768 //–32768 до 32767

var e4 int32 = 2147483647 //–2147483648 до 2147483647

/*то же самое только целое число - unsigned*/
var symplyuint = 1

var f4 uint8 = 255 //от 0 до 255

var g4 uint16 = 32768 //от 0 до 2*10^16-1

var h4 uint32 = 2147483647 //от 0 до 2*10^32-1

//////////////////////////////
var i4 byte = 255 //то же что и uint8

var j4 rune = 10000000 //то же что и int32 - пространство Юникода ( 2^31)

/////////////////////////
var k4 float32 = 1.1555556 //округляет до определенного диапазона после запятой

var l4 float64 = 1.155555555555550001111114444444444444444444444444444444444444333333

////////////////////////
//комплексные числа: 1 часть числа явная, а вторая - мнимая i= корень с -1
var m4 complex64 = -1 + 130i

var n4 complex128 = -1 + 100i

//////////////////
//указатель на адрес в памяти тип uinptr, получить можно с помощью ссылки & на что либо
//todo для чего используется?
var uinptr4 uintptr = 0x538490 //

func main() {

	/*получить тип переменной*/
	fmt.Println(reflect.TypeOf(uinptr4)) //uinptr4
	/*сконвертировать один тип в другой: type(variable)*/
	v := string(uinptr4)
	fmt.Println(reflect.TypeOf(v)) //string
}

//Зачем?
// иногда полезно экономить память и указывать сразу тип с ограничителем,
// например int8 вместо int

// Простой пример комплексного типа i := 1+1i

///////////ДОПОЛНИТЕЛЬНО
//константы, не изменяются до конца кода
const myConst = 1
const (
	AAA = 1
	BBB = 2
)
